---
title: The Move to Higher-Level Languages - Compilers - Computer Science
type: default
layout: page
child: Computer Science
fold: Compilers
---

The first step towards more people-friendly programming languages was the
development of mnemonic assembly languages in the early 1950's. Initially, the
instructions in an assembly language were just mnemonic representations of
machine instructions. Later, macro instructions were added to assembly languages
so that a programmer could define parameterised shorthands for frequently used
sequences of machine instructions.

A major step towards higher-level languages was made in the latter half of the
1950's with the development of Fortran for scientific computation, Cobol for
business data processing, and Lisp for symbolic computation. The philosophy
behind these languages was to create higher-level notations with which
programmers could more easily write numerical computations, business
applications and symbolic programs. These languages were so successful that they
are still in use today.

In the following decades, many more languages were created with innovative
features to help make programming easier, more natural and more robust. Later,
we will discuss some key features that are common to many modern programming
languages.

Today, there are thousands of programming languages. They can be classified in a
variety of ways. One classification is by generation. _First-generation
languages_ are the machine languages, _second-generation_ the assembly
languages, and _third generation_ the higher level languages like Fortran,
Cobol, Lisp, C and Java. _Fourth-generation languages_ are languages designed
for specific applications like NOMAD for report generation, SQL for database
queries and Postscript for text formatting. The term _fifth-generation language_
has been applied to logic - and constraint - based languages like Prolog and
OPS5.

Another classification of languages uses the term _imperative_ for languages in
which a program specifies _how_ a computation is to be done and _declarative_
for languages in which a program specifies _what_ computation is to be done.
Languages such as C, C++ and Java are imperative langauges. In imperative
languages there is a notion of program state and statements that change the
state. Functional languages such as ML and Haskell and constraint logic
languages such as Prolog are often considered to be declarative languages.

The term _von Neumann language_ is applied to programming languages whose
computational model is based on the von Neumann computer architecture. Many
of today's languages, such as Fortran and C are von Neumann languages.

An _object-oriented language_ is one that supports object-oriented programming,
a programming style in which program consists of a collection of objects that
interact with one another. Simula 67 and Smalltalk are the earliest major
object-oriented languages. Languages such as C++, C#, Java and Ruby are more
recent object-oriented languages.

_Scripting languages_ are interpreted languages with high-level operators
designed for "gluing together" computations. these computations were originally
called "scripts". Awk, JavaScript, Perl, PHP, Python, Ruby and Tel are popular
examples of scripting languages. Programs written in scripting languages are
often much shorter than equivalent programs written in languages like C.
